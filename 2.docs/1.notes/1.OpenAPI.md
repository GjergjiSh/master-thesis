# Interface Description Languages

## Contract First Approach

### Why? Benefits of Contract First Approach

## Contract First Approach

We need to document the upsides
We need to document the upsides

# OAS - OpenAPI Specification

```yaml
# Define the OpenAPI version
openapi: 3.0.0

# Define general information about the API
info:
  title: Sensor Data Analysis App API
  version: 1.0.0

# Define the server(s) where the API is hosted
servers:
  - url: http://localhost:8000

# Define the available paths and operations for the API
paths:
  /sensor_data:
    # Define the GET operation for the /sensor_data path
    get:
      summary: Get all sensor data
      responses:
        '200':
          description: OK
        '404':
          description: Not Found

    # Define the POST operation for the /sensor_data path
    post:
      summary: Create a new sensor data entry
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/SensorData'
      responses:
        '201':
          description: Created
        '400':
          description: Bad Request

    # Define the PUT operation for the /sensor_data path
    put:
      summary: Update an existing sensor data entry
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/SensorData'
      responses:
        '200':
          description: OK
        '400':
          description: Bad Request

    # Define the DELETE operation for the /sensor_data path
    delete:
      summary: Delete an existing sensor data entry
      responses:
        '204':
          description: No Content

# Define reusable components for the API
components:
  schemas:
    # Define the SensorData model schema
    SensorData:
      type: object
      properties:
        id:
          type: integer
        timestamp:
          type: string
          format: date-time
        value:
          type: number
```

## Model

- The model is the data structure that is used to represent the data that is sent and received by the API.
- The model is defined using the OpenAPI Specification's Schema Object.
- The generated code will include a class that represents the model, and the class will have properties that correspond to the properties defined in the Schema Object.

## Operations

```yaml

```

## Return types

```yaml

```

## Parameters

```yaml

```

## Documentation


```yaml

```

- In code
- Markdown

# OpenAPI Generator

The OpenAPI Generator can generate a variety of things on a system level, including:

- Client SDKs for a wide range of programming languages and frameworks, including Java, Python, Ruby, and TypeScript.
- Server stubs for a variety of server-side frameworks, including Spring Boot, Flask, and Ruby on Rails.
- API documentation in a variety of formats, including HTML, Markdown, and PDF.
- Integration with various tooling and IDEs, including Visual Studio Code, Eclipse, and IntelliJ IDEA.
- Custom code generators that can be used to generate code for specific use cases or frameworks.

Overall, the OpenAPI Generator is a powerful tool that can help developers quickly generate code and documentation for their APIs, and it can be customized to fit a wide range of use cases and requirements

- Templated Client SDK Generation
- Templated REST API Generation
- Template Documentation Generation
- Tooling Support

## Templating Engine

- Mustache
- Handlebars

## Templates

### Operations
### Models
### Supporting Files

## OpenAPI Generator CLI
    - CLI Based tool for generating code
    - Requires a yaml file describing the rest api
        - OAS, AAS, RAML, Smithy, GraphQL, etc.
    - Executes a generator
        - Java, Python, Ruby, etc.
    - Requires template files
        - Mustache, Handlebars, etc.
        - Templates are language specific
        - The mustache syntax is the same for all languages



